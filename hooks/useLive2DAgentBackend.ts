/**
 * useLive2DAgentBackend Hook - Agent 服务器后端管理
 * 
 * 从 N.E.K.O Web 版本同步而来，用于管理 Agent 服务器的状态和控制
 * 
 * 功能：
 * - Agent 健康检查
 * - Agent flags 管理（agent_enabled, computer_use_enabled, mcp_enabled, user_plugin_enabled）
 * - 可用性检查（keyboard/mcp/userPlugin）
 * - 管理员控制（enable_analyzer/disable_analyzer）
 * - 自动轮询机制
 */

import { useCallback, useEffect, useRef, useState } from 'react';
import { createRequestClient } from '@project_neko/request';
import type { TokenRefreshFn, TokenStorage } from '@project_neko/request';

export type Live2DAgentToggleId = 'master' | 'keyboard' | 'mcp' | 'userPlugin';

export interface Live2DAgentState {
  statusText: string;
  master: boolean;
  keyboard: boolean;
  mcp: boolean;
  userPlugin: boolean;
  disabled: Partial<Record<Live2DAgentToggleId, boolean>>;
}

type AgentFlagsKey = 'agent_enabled' | 'computer_use_enabled' | 'mcp_enabled' | 'user_plugin_enabled';

type AgentFlagsResponse = {
  success: boolean;
  agent_flags?: Partial<Record<AgentFlagsKey, boolean>>;
  analyzer_enabled?: boolean;
  notification?: string;
  error?: string;
};

export interface UseLive2DAgentBackendArgs {
  apiBase: string;
  /**
   * 翻译函数（可选），用于国际化
   * 在 RN 中可以传入 i18n.t
   */
  t?: (key: string, fallback?: string) => string;
  /**
   * Toast 显示函数（可选）
   * 在 RN 中可以使用 Toast.show() 或 Alert.alert()
   */
  showToast?: (message: string, duration?: number) => void;
  /**
   * 当前打开的面板（用于决定是否轮询）
   */
  openPanel?: 'agent' | null;
}

export interface UseLive2DAgentBackendResult {
  agent: Live2DAgentState;
  onAgentChange: (id: Live2DAgentToggleId, next: boolean) => void;
  refreshAgentState: () => Promise<void>;
}

/**
 * 翻译工具函数：如果有翻译函数就用，否则返回 fallback
 */
function tOrDefault(t: ((key: string, fallback?: string) => string) | undefined, key: string, fallback: string): string {
  return t ? t(key, fallback) : fallback;
}

/**
 * 主界面 Agent 后端不强制鉴权，但 request client 需要提供存储/刷新函数。
 * 这里使用一个 no-op 存储 + 永远失败的 refreshApi，避免无 token 场景引入额外依赖。
 */
class NoopTokenStorage implements TokenStorage {
  async getAccessToken(): Promise<string | null> {
    return null;
  }
  async setAccessToken(_token: string): Promise<void> {}
  async getRefreshToken(): Promise<string | null> {
    return null;
  }
  async setRefreshToken(_token: string): Promise<void> {}
  async clearTokens(): Promise<void> {}
}

const noopRefreshApi: TokenRefreshFn = async () => {
  throw new Error('No refresh token available');
};

export function useLive2DAgentBackend({
  apiBase,
  t,
  showToast,
  openPanel,
}: UseLive2DAgentBackendArgs): UseLive2DAgentBackendResult {
  const clientRef = useRef(
    createRequestClient({
      baseURL: apiBase.trim().replace(/\/+$/, ''),
      storage: new NoopTokenStorage(),
      refreshApi: noopRefreshApi,
      // Agent 状态轮询较频繁，避免默认超时过长导致堆积
      timeout: 8000,
      returnDataOnly: true,
      logEnabled: false,
    }),
  );

  // apiBase 变化时重建 client（开发扫码切换 host/port 时需要）
  useEffect(() => {
    clientRef.current = createRequestClient({
      baseURL: apiBase.trim().replace(/\/+$/, ''),
      storage: new NoopTokenStorage(),
      refreshApi: noopRefreshApi,
      timeout: 8000,
      returnDataOnly: true,
      logEnabled: false,
    });
  }, [apiBase]);

  const agentUserOpSeqRef = useRef(0);
  const agentRefreshSeqRef = useRef(0);
  const agentProcessingRef = useRef(false);
  const agentPollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const availabilityCacheRef = useRef<{
    updatedAt: number;
    keyboard?: boolean;
    mcp?: boolean;
    userPlugin?: boolean;
  }>({ updatedAt: 0 });

  const [agent, setAgent] = useState<Live2DAgentState>({
    statusText: tOrDefault(t, 'settings.toggles.checking', '查询中...'),
    master: false,
    keyboard: false,
    mcp: false,
    userPlugin: false,
    disabled: {},
  });

  const fetchAgentHealth = useCallback(async (): Promise<boolean> => {
    try {
      await clientRef.current.get('/api/agent/health');
      return true;
    } catch (_e) {
      return false;
    }
  }, []);

  const fetchAgentFlags = useCallback(async (): Promise<AgentFlagsResponse> => {
    try {
      const data = (await clientRef.current.get('/api/agent/flags')) as AgentFlagsResponse;
      return data;
    } catch (e) {
      return { success: false, error: String(e) };
    }
  }, []);

  const fetchAvailability = useCallback(
    async (kind: 'computer_use' | 'mcp' | 'user_plugin'): Promise<boolean> => {
      const map: Record<'computer_use' | 'mcp' | 'user_plugin', string> = {
        computer_use: `/api/agent/computer_use/availability`,
        mcp: `/api/agent/mcp/availability`,
        user_plugin: `/api/agent/user_plugin/availability`,
      };
      try {
        const data = (await clientRef.current.get(map[kind])) as { ready?: boolean };
        return Boolean(data?.ready);
      } catch (_e) {
        return false;
      }
    },
    []
  );

  const updateAvailabilityCache = useCallback(
    async (opts?: { force?: boolean; refreshSeq?: number }) => {
      const now = Date.now();
      const cache = availabilityCacheRef.current;
      const force = Boolean(opts?.force);
      const shouldRefresh = force || now - cache.updatedAt > 5000;
      if (!shouldRefresh) return;
      if (agentProcessingRef.current) return;

      const [keyboardAvailable, mcpAvailable, userPluginAvailable] = await Promise.all([
        fetchAvailability('computer_use'),
        fetchAvailability('mcp'),
        fetchAvailability('user_plugin'),
      ]);

      if (agentProcessingRef.current) return;
      if (typeof opts?.refreshSeq === 'number' && opts.refreshSeq !== agentRefreshSeqRef.current) return;

      availabilityCacheRef.current = {
        updatedAt: Date.now(),
        keyboard: keyboardAvailable,
        mcp: mcpAvailable,
        userPlugin: userPluginAvailable,
      };
    },
    [fetchAvailability]
  );

  const refreshAgentState = useCallback(async () => {
    if (agentProcessingRef.current) return;
    const seq = ++agentRefreshSeqRef.current;

    const [healthOk, flagsData] = await Promise.all([fetchAgentHealth(), fetchAgentFlags()]);

    if (seq !== agentRefreshSeqRef.current) return;

    if (flagsData.notification && showToast) {
      showToast(flagsData.notification, 3000);
    }

    if (!healthOk || !flagsData.success) {
      setAgent((prev) => ({
        ...prev,
        statusText: tOrDefault(t, 'settings.toggles.serverOffline', 'Agent服务器未启动'),
        master: false,
        keyboard: false,
        mcp: false,
        userPlugin: false,
        disabled: {
          master: true,
          keyboard: true,
          mcp: true,
          userPlugin: true,
        },
      }));
      return;
    }

    const analyzerEnabled = Boolean(flagsData.analyzer_enabled);
    const flags = flagsData.agent_flags || {};

    // availability 结果缓存：刷新不阻塞 UI
    const cachedAvail = availabilityCacheRef.current;
    const keyboardAvailable = cachedAvail.keyboard ?? false;
    const mcpAvailable = cachedAvail.mcp ?? false;
    const userPluginAvailable = cachedAvail.userPlugin ?? false;

    if (!analyzerEnabled) {
      setAgent((prev) => ({
        ...prev,
        statusText: tOrDefault(t, 'agent.status.ready', 'Agent服务器就绪'),
        master: false,
        keyboard: false,
        mcp: false,
        userPlugin: false,
        disabled: {
          master: false,
          keyboard: true,
          mcp: true,
          userPlugin: true,
        },
      }));
      return;
    }

    setAgent((prev) => ({
      ...prev,
      statusText: tOrDefault(t, 'agent.status.enabled', 'Agent模式已开启'),
      master: true,
      keyboard: Boolean(flags.computer_use_enabled) && keyboardAvailable,
      mcp: Boolean(flags.mcp_enabled) && mcpAvailable,
      userPlugin: Boolean(flags.user_plugin_enabled) && userPluginAvailable,
      disabled: {
        master: false,
        keyboard: !keyboardAvailable,
        mcp: !mcpAvailable,
        userPlugin: !userPluginAvailable,
      },
    }));

    // 异步刷新 availability（不阻塞本次渲染）
    void (async () => {
      if (!analyzerEnabled) return;
      await updateAvailabilityCache({ refreshSeq: seq });
      if (agentProcessingRef.current) return;
      if (seq !== agentRefreshSeqRef.current) return;

      const updated = availabilityCacheRef.current;
      const k = updated.keyboard ?? false;
      const m = updated.mcp ?? false;
      const u = updated.userPlugin ?? false;

      setAgent((prev) => ({
        ...prev,
        keyboard: Boolean(flags.computer_use_enabled) && k,
        mcp: Boolean(flags.mcp_enabled) && m,
        userPlugin: Boolean(flags.user_plugin_enabled) && u,
        disabled: {
          master: false,
          keyboard: !k,
          mcp: !m,
          userPlugin: !u,
        },
      }));
    })();
  }, [fetchAgentFlags, fetchAgentHealth, t, showToast, updateAvailabilityCache]);

  const postAgentFlags = useCallback(
    async (flags: Partial<Record<AgentFlagsKey, boolean>>) => {
      const data = (await clientRef.current.post('/api/agent/flags', { flags })) as { success?: boolean; error?: string };
      if (data && data.success === false) throw new Error(data.error || 'flags_failed');
    },
    []
  );

  const postAdminControl = useCallback(
    async (action: 'enable_analyzer' | 'disable_analyzer') => {
      const data = (await clientRef.current.post('/api/agent/admin/control', { action })) as { success?: boolean; error?: string };
      if (data && data.success === false) throw new Error(data.error || 'admin_failed');
    },
    []
  );

  const onAgentChange = useCallback(
    (id: Live2DAgentToggleId, next: boolean) => {
      void (async () => {
        const seq = ++agentUserOpSeqRef.current;
        agentProcessingRef.current = true;

        const setProcessingState = (patch: Partial<Live2DAgentState>, disabledAll: boolean) => {
          setAgent((prev) => ({
            ...prev,
            ...patch,
            disabled: disabledAll
              ? {
                  master: true,
                  keyboard: true,
                  mcp: true,
                  userPlugin: true,
                }
              : { ...prev.disabled, ...(patch.disabled || {}) },
          }));
        };

        try {
          if (id === 'master') {
            if (next) {
              setProcessingState(
                {
                  statusText: tOrDefault(t, 'agent.status.connecting', 'Agent服务器连接中...'),
                  master: true,
                  keyboard: false,
                  mcp: false,
                  userPlugin: false,
                },
                true
              );

              const healthOk = await fetchAgentHealth();
              if (seq !== agentUserOpSeqRef.current) return;
              if (!healthOk) {
                showToast?.(tOrDefault(t, 'settings.toggles.serverOffline', 'Agent服务器未启动'), 3000);
                await refreshAgentState();
                return;
              }

              await postAgentFlags({
                agent_enabled: true,
                computer_use_enabled: false,
                mcp_enabled: false,
                user_plugin_enabled: false,
              });
              if (seq !== agentUserOpSeqRef.current) return;

              await postAdminControl('enable_analyzer');
              if (seq !== agentUserOpSeqRef.current) return;

              setAgent((prev) => ({
                ...prev,
                statusText: tOrDefault(t, 'agent.status.enabled', 'Agent模式已开启'),
                master: true,
                keyboard: false,
                mcp: false,
                userPlugin: false,
                disabled: {
                  master: false,
                  keyboard: true,
                  mcp: true,
                  userPlugin: true,
                },
              }));
              agentProcessingRef.current = false;
              void refreshAgentState();
              return;
            }

            setProcessingState(
              {
                statusText: tOrDefault(t, 'agent.status.disabled', 'Agent模式已关闭'),
                master: false,
                keyboard: false,
                mcp: false,
                userPlugin: false,
              },
              true
            );

            await postAdminControl('disable_analyzer');
            if (seq !== agentUserOpSeqRef.current) return;
            await postAgentFlags({
              agent_enabled: false,
              computer_use_enabled: false,
              mcp_enabled: false,
              user_plugin_enabled: false,
            });
            if (seq !== agentUserOpSeqRef.current) return;

            setAgent((prev) => ({
              ...prev,
              statusText: tOrDefault(t, 'agent.status.disabled', 'Agent模式已关闭'),
              master: false,
              keyboard: false,
              mcp: false,
              userPlugin: false,
              disabled: {
                master: false,
                keyboard: true,
                mcp: true,
                userPlugin: true,
              },
            }));
            agentProcessingRef.current = false;
            void refreshAgentState();
            return;
          }

          if (!agent.master) {
            await refreshAgentState();
            return;
          }

          setAgent((prev) => ({
            ...prev,
            [id]: next,
            disabled: { ...prev.disabled, [id]: true },
          }));

          const availabilityMap: Record<Exclude<Live2DAgentToggleId, 'master'>, 'computer_use' | 'mcp' | 'user_plugin'> = {
            keyboard: 'computer_use',
            mcp: 'mcp',
            userPlugin: 'user_plugin',
          };
          const flagKeyMap: Record<Exclude<Live2DAgentToggleId, 'master'>, AgentFlagsKey> = {
            keyboard: 'computer_use_enabled',
            mcp: 'mcp_enabled',
            userPlugin: 'user_plugin_enabled',
          };

          const kind = availabilityMap[id];
          const flagKey = flagKeyMap[id];

          if (next) {
            const available = await fetchAvailability(kind);
            if (seq !== agentUserOpSeqRef.current) return;
            if (!available) {
              showToast?.(tOrDefault(t, 'settings.toggles.unavailable', '功能不可用'), 3000);
              await refreshAgentState();
              return;
            }
          }

          await postAgentFlags({ [flagKey]: next });
          if (seq !== agentUserOpSeqRef.current) return;
          agentProcessingRef.current = false;
          void refreshAgentState();
        } catch (e) {
          if (seq === agentUserOpSeqRef.current) {
            showToast?.(String(e), 3000);
            agentProcessingRef.current = false;
            void refreshAgentState();
          }
        } finally {
          if (seq === agentUserOpSeqRef.current) {
            agentProcessingRef.current = false;
          }
        }
      })();
    },
    [agent.master, fetchAgentHealth, fetchAvailability, postAdminControl, postAgentFlags, refreshAgentState, t, showToast]
  );

  // 自动轮询（当 openPanel 为 'agent' 或 master 开启时）
  useEffect(() => {
    const shouldPoll = openPanel === 'agent' || agent.master;
    if (!shouldPoll) {
      if (agentPollRef.current) {
        clearInterval(agentPollRef.current);
        agentPollRef.current = null;
      }
      return;
    }

    refreshAgentState();
    if (agentPollRef.current) {
      clearInterval(agentPollRef.current);
      agentPollRef.current = null;
    }
    agentPollRef.current = setInterval(() => {
      refreshAgentState();
    }, 1500);

    return () => {
      if (agentPollRef.current) {
        clearInterval(agentPollRef.current);
        agentPollRef.current = null;
      }
    };
  }, [agent.master, openPanel, refreshAgentState]);

  return { agent, onAgentChange, refreshAgentState };
}
